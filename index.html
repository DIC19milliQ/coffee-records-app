<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coffee Records</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      --bg: #f7f5f2;
      --card: #ffffff;
      --text: #2f2a24;
      --muted: #6c6156;
      --accent: #7b4e2e;
      --accent-soft: #f1e4d8;
      --line: #e2d8cd;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 20px 16px 12px;
      background: var(--card);
      border-bottom: 1px solid var(--line);
    }
    header h1 {
      margin: 0 0 8px;
      font-size: 1.6rem;
    }
    .header-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    button {
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      padding: 6px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button.ghost {
      background: transparent;
      color: var(--accent);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    nav {
      display: flex;
      gap: 6px;
      padding: 8px 16px;
      background: var(--card);
      border-bottom: 1px solid var(--line);
      position: sticky;
      top: 0;
      z-index: 10;
      overflow-x: auto;
    }
    nav button {
      background: var(--accent-soft);
      color: var(--text);
      border: 1px solid var(--line);
      padding: 6px 14px;
      border-radius: 999px;
      white-space: nowrap;
    }
    nav button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    main {
      padding: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .tab-panel {
      display: none;
      gap: 16px;
      flex-direction: column;
    }
    .tab-panel.active {
      display: flex;
    }
    .card {
      background: var(--card);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.04);
      border: 1px solid var(--line);
    }
    .card h2 {
      margin-top: 0;
    }
    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .checkbox-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 12px;
    }
    input[type="text"], input[type="number"], select {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--line);
      width: 100%;
      font-size: 0.95rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--line);
      vertical-align: top;
    }
    tr.expandable {
      cursor: pointer;
    }
    tr.note-row td {
      background: #faf6f2;
      color: var(--muted);
    }
    .tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: var(--accent-soft);
      color: var(--text);
    }
    .mode-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .mode-buttons button {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--line);
    }
    .mode-buttons button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }
    .muted {
      color: var(--muted);
    }
    .result-count {
      font-size: 0.9rem;
      color: var(--muted);
    }
    .chart-container {
      width: 100%;
      overflow-x: auto;
    }
    canvas {
      width: 100%;
      max-width: 640px;
      height: 360px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
    }
    #map {
      width: 100%;
      overflow-x: auto;
    }
    #map svg {
      width: 100%;
      height: auto;
      min-height: 360px;
    }
    .legend {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .legend-bar {
      width: 160px;
      height: 10px;
      background: linear-gradient(90deg, #f5f3ef, #e0b98c, #c8783b, #8b3f1f);
      border-radius: 999px;
      border: 1px solid var(--line);
    }
    .pill {
      background: var(--accent-soft);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.8rem;
    }
    dialog {
      border: none;
      border-radius: 16px;
      padding: 0;
      max-width: 520px;
      width: 90%;
    }
    dialog::backdrop {
      background: rgba(0,0,0,0.3);
    }
    .dialog-body {
      padding: 20px;
    }
    .dialog-actions {
      display: flex;
      justify-content: flex-end;
      padding: 12px 20px 20px;
      gap: 8px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
</head>
<body>
  <header>
    <h1>コーヒー豆記録</h1>
    <div class="header-row">
      <div id="status" class="muted">読み込み中...</div>
      <div class="header-actions">
        <span class="pill">最終取得: <span id="updated-at">--</span></span>
        <button id="reload">再取得</button>
      </div>
    </div>
  </header>
  <nav>
    <button class="active" data-tab="search">Search</button>
    <button data-tab="ranking">Ranking</button>
    <button data-tab="analysis">Analysis</button>
    <button data-tab="map">Map</button>
  </nav>
  <main>
    <section id="tab-search" class="tab-panel active">
      <div class="card">
        <h2>検索 / 図鑑</h2>
        <div class="filters">
          <input id="search-input" type="text" placeholder="キーワードを入力（スペースでAND検索）" />
          <span class="result-count" id="search-count">0件</span>
        </div>
        <div class="checkbox-grid" id="search-columns"></div>
      </div>
      <div class="card">
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>日付</th>
                <th>豆</th>
                <th>産地</th>
                <th>焙煎</th>
                <th>評価</th>
                <th>店</th>
              </tr>
            </thead>
            <tbody id="search-results"></tbody>
          </table>
        </div>
        <div style="margin-top:12px;">
          <button id="show-more" class="ghost">もっと見る</button>
        </div>
      </div>
    </section>

    <section id="tab-ranking" class="tab-panel">
      <div class="card">
        <h2>ランキング：気分入力</h2>
        <div class="mode-buttons" id="ranking-modes">
          <button data-mode="bitter" class="active">Bitterのみ</button>
          <button data-mode="both">Bitter + Acid</button>
          <button data-mode="diff">差分 (B - A)</button>
        </div>
        <div class="grid-2" style="margin-top:12px;">
          <div>
            <label>Bitter (1-5)</label>
            <input id="input-bitter" type="number" min="1" max="5" step="1" value="3" />
          </div>
          <div>
            <label>Acid (1-5)</label>
            <input id="input-acid" type="number" min="1" max="5" step="1" value="3" />
          </div>
          <div>
            <label>差分 (B - A)</label>
            <input id="input-diff" type="number" min="-4" max="4" step="1" value="0" />
          </div>
        </div>
        <p class="muted" id="ranking-note">有効なBitter/Acidのみ対象。近い順に表示されます。</p>
      </div>
      <div class="card">
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>スコア</th>
                <th>豆</th>
                <th>産地</th>
                <th>Bitter</th>
                <th>Acid</th>
                <th>評価</th>
                <th>日付</th>
              </tr>
            </thead>
            <tbody id="ranking-results"></tbody>
          </table>
        </div>
      </div>
    </section>

    <section id="tab-analysis" class="tab-panel">
      <div class="grid-2">
        <div class="card">
          <h2>高評価豆の共通点</h2>
          <div class="filters">
            <label><input type="radio" name="rating-filter" value="S" checked /> Sのみ</label>
            <label><input type="radio" name="rating-filter" value="SA" /> S + A</label>
          </div>
          <p id="analysis-sample" class="muted"></p>
          <div id="analysis-traits"></div>
        </div>
        <div class="card">
          <h2>Bitter x Acid マップ</h2>
          <div class="chart-container">
            <canvas id="scatter" width="640" height="360"></canvas>
          </div>
          <div class="legend">
            <span class="tag">S</span>
            <span class="tag">A</span>
            <span class="tag">B</span>
            <span class="tag">C</span>
            <span class="tag">その他</span>
          </div>
        </div>
      </div>
      <div class="card">
        <h2>AI分析（準備中）</h2>
        <p class="muted">現在は集計結果の確認のみ。将来は集計結果をAIに渡す想定です。</p>
        <button id="ai-button">AI分析へ切替</button>
      </div>
    </section>

    <section id="tab-map" class="tab-panel">
      <div class="card">
        <h2>コンプリート地図</h2>
        <p class="muted">国ごとの豆の種類数（ユニーク数）を可視化。P95で上限を切り、平方根スケールで色付けしています。</p>
        <div id="map"></div>
        <div class="legend">
          <span>少ない</span>
          <div class="legend-bar"></div>
          <span>多い</span>
        </div>
      </div>
      <div class="card">
        <h3>未マッピングの国</h3>
        <p class="muted">地図側の国名またはISO2コードを登録してください。</p>
        <div id="unmapped-list"></div>
        <div class="grid-2" style="margin-top:12px;">
          <div>
            <label>対象国</label>
            <select id="unmapped-select"></select>
          </div>
          <div>
            <label>マップキー（国名 or ISO2）</label>
            <input id="mapping-input" type="text" placeholder="例: Brazil / BR" />
          </div>
        </div>
        <button id="save-mapping" style="margin-top:12px;">マッピング保存</button>
      </div>
    </section>
  </main>

  <dialog id="ai-dialog">
    <div class="dialog-body">
      <h3>AI分析は準備中です</h3>
      <p class="muted">今後は集計データのみをAIに渡して分析する想定です。現時点ではAPI連携は行いません。</p>
    </div>
    <div class="dialog-actions">
      <button id="ai-close" class="ghost">閉じる</button>
    </div>
  </dialog>

  <script>
    const API_URL = "https://script.google.com/macros/s/AKfycbwTVElQ-Ao7U2lb3MGsYFj_Qy5K0C1bSw_IPk0ZFNPV9d0mGrpOZuukZCW9rbOgtc_6/exec";
    const TTL_MS = 60 * 60 * 1000;
    const LS_KEY = "coffeeRecordsCache_v2";
    const MAP_KEY = "coffeeCountryMapping_v1";

    const SEARCH_COLUMNS = [
      { key: "region", label: "地域" },
      { key: "country", label: "国" },
      { key: "bean", label: "豆" },
      { key: "altitude", label: "標高" },
      { key: "process", label: "精製" },
      { key: "roast", label: "焙煎" },
      { key: "price", label: "価格" },
      { key: "rating", label: "評価" },
      { key: "bitter", label: "Bitter" },
      { key: "acid", label: "Acid" },
      { key: "note", label: "ノート" },
      { key: "shop", label: "ショップ" },
      { key: "date", label: "日付" }
    ];

    const DEFAULT_MAPPING = {
      "ブラジル": "Brazil",
      "コロンビア": "Colombia",
      "エチオピア": "Ethiopia",
      "グアテマラ": "Guatemala",
      "ホンジュラス": "Honduras",
      "インドネシア": "Indonesia",
      "ケニア": "Kenya",
      "ペルー": "Peru",
      "ルワンダ": "Rwanda",
      "タンザニア": "Tanzania",
      "ベトナム": "Vietnam",
      "イエメン": "Yemen",
      "コスタリカ": "Costa Rica",
      "パナマ": "Panama",
      "ボリビア": "Bolivia",
      "ブルンジ": "Burundi",
      "エクアドル": "Ecuador",
      "エルサルバドル": "El Salvador",
      "インド": "India",
      "ジャマイカ": "Jamaica",
      "ニカラグア": "Nicaragua",
      "パプアニューギニア": "Papua New Guinea",
      "ウガンダ": "Uganda"
    };

    const ISO2_TO_NAME = {
      BR: "Brazil",
      CO: "Colombia",
      ET: "Ethiopia",
      GT: "Guatemala",
      HN: "Honduras",
      ID: "Indonesia",
      KE: "Kenya",
      PE: "Peru",
      RW: "Rwanda",
      TZ: "Tanzania",
      VN: "Vietnam",
      YE: "Yemen",
      CR: "Costa Rica",
      PA: "Panama",
      BO: "Bolivia",
      BI: "Burundi",
      EC: "Ecuador",
      SV: "El Salvador",
      IN: "India",
      JM: "Jamaica",
      NI: "Nicaragua",
      PG: "Papua New Guinea",
      UG: "Uganda",
      US: "United States of America",
      JP: "Japan"
    };

    const state = {
      records: [],
      updatedAt: "--",
      search: {
        query: "",
        columns: new Set(SEARCH_COLUMNS.map((col) => col.key)),
        limit: 100
      },
      rankingMode: "bitter",
      worldFeatures: null,
      mapping: {}
    };

    const statusEl = document.getElementById("status");
    const updatedEl = document.getElementById("updated-at");
    const reloadBtn = document.getElementById("reload");

    function normalizeText(value) {
      return String(value ?? "")
        .replace(/^\uFEFF/, "")
        .normalize("NFKC")
        .toLowerCase()
        .trim();
    }

    function isHeaderRow(record) {
      const fields = ["region", "country", "bean", "altitude", "process", "roast", "price", "rating", "bitter", "acid", "note", "shop", "date"];
      return fields.some((field) => normalizeText(record[field]) === field);
    }

    function validTaste(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return null;
      if (num < 1 || num > 5) return null;
      return num;
    }

    function formatDate(value) {
      if (!value) return "—";
      return value;
    }

    function getDateValue(value) {
      if (!value) return -Infinity;
      const time = Date.parse(value);
      return Number.isFinite(time) ? time : -Infinity;
    }

    function safeParseJson(text) {
      const cleaned = text.replace(/^\uFEFF/, "");
      return JSON.parse(cleaned);
    }

    function cacheSet(payload) {
      localStorage.setItem(LS_KEY, JSON.stringify({ savedAt: Date.now(), payload }));
    }

    function cacheGet() {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return null;
      try {
        const parsed = JSON.parse(raw);
        if (!parsed.savedAt || !parsed.payload) return null;
        if (Date.now() - parsed.savedAt > TTL_MS) return null;
        return parsed.payload;
      } catch (error) {
        return null;
      }
    }

    function loadMapping() {
      const raw = localStorage.getItem(MAP_KEY);
      if (!raw) return { ...DEFAULT_MAPPING };
      try {
        return { ...DEFAULT_MAPPING, ...JSON.parse(raw) };
      } catch (error) {
        return { ...DEFAULT_MAPPING };
      }
    }

    function saveMapping(mapping) {
      localStorage.setItem(MAP_KEY, JSON.stringify(mapping));
    }

    function resolveMapKey(jpName, mapping) {
      const mapped = mapping[jpName];
      if (!mapped) return null;
      const trimmed = mapped.trim();
      if (trimmed.length === 2) {
        const upper = trimmed.toUpperCase();
        return ISO2_TO_NAME[upper] || null;
      }
      return trimmed;
    }

    async function fetchRecords() {
      statusEl.textContent = "取得中...";
      const response = await fetch(API_URL, { method: "GET" });
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      const text = await response.text();
      const data = safeParseJson(text);
      return data;
    }

    function sanitizeRecords(items) {
      if (!Array.isArray(items)) return [];
      return items
        .filter((item) => item && typeof item === "object")
        .filter((item) => !isHeaderRow(item))
        .map((item) => {
          const cleaned = {};
          SEARCH_COLUMNS.forEach((col) => {
            cleaned[col.key] = item[col.key] ?? "";
          });
          cleaned._norm = {};
          SEARCH_COLUMNS.forEach((col) => {
            cleaned._norm[col.key] = normalizeText(cleaned[col.key]);
          });
          return cleaned;
        });
    }

    function updateStatus(text) {
      statusEl.textContent = text;
    }

    function updateUpdatedAt(value) {
      updatedEl.textContent = value || "--";
    }

    async function loadData(force = false) {
      reloadBtn.disabled = true;
      try {
        if (!force) {
          const cached = cacheGet();
          if (cached) {
            state.records = sanitizeRecords(cached.items || []);
            state.updatedAt = cached.updatedAt || cached.fetchedAt || "--";
            updateStatus("キャッシュから読み込み");
            updateUpdatedAt(state.updatedAt);
            renderAll();
            reloadBtn.disabled = false;
            return;
          }
        }

        const data = await fetchRecords();
        const fetchedAt = new Date().toISOString();
        cacheSet({ items: data.items || [], updatedAt: data.updatedAt, fetchedAt });
        state.records = sanitizeRecords(data.items || []);
        state.updatedAt = data.updatedAt || fetchedAt;
        updateStatus("APIから読み込み");
        updateUpdatedAt(state.updatedAt);
        renderAll();
      } catch (error) {
        updateStatus(`エラー: ${error.message}`);
      } finally {
        reloadBtn.disabled = false;
      }
    }

    function setupTabs() {
      document.querySelectorAll("nav button").forEach((button) => {
        button.addEventListener("click", () => {
          document.querySelectorAll("nav button").forEach((btn) => btn.classList.remove("active"));
          document.querySelectorAll(".tab-panel").forEach((panel) => panel.classList.remove("active"));
          button.classList.add("active");
          document.getElementById(`tab-${button.dataset.tab}`).classList.add("active");
        });
      });
    }

    function setupSearchColumns() {
      const container = document.getElementById("search-columns");
      container.innerHTML = "";
      SEARCH_COLUMNS.forEach((col) => {
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = true;
        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            state.search.columns.add(col.key);
          } else {
            state.search.columns.delete(col.key);
          }
          renderSearchResults();
        });
        label.appendChild(checkbox);
        label.append(` ${col.label}`);
        container.appendChild(label);
      });
    }

    function debounce(fn, delay) {
      let timer = null;
      return (...args) => {
        if (timer) window.clearTimeout(timer);
        timer = window.setTimeout(() => fn(...args), delay);
      };
    }

    function filterRecords() {
      const tokens = normalizeText(state.search.query)
        .split(/\s+/)
        .filter(Boolean);
      const columns = Array.from(state.search.columns);
      if (!tokens.length || !columns.length) return state.records;
      return state.records.filter((record) =>
        tokens.every((token) =>
          columns.some((col) => record._norm[col].includes(token))
        )
      );
    }

    function renderSearchResults() {
      const tbody = document.getElementById("search-results");
      tbody.innerHTML = "";
      const results = filterRecords();
      const limit = state.search.limit;
      document.getElementById("search-count").textContent = `${results.length}件`;

      results.slice(0, limit).forEach((record) => {
        const row = document.createElement("tr");
        row.classList.add("expandable");
        row.innerHTML = `
          <td>${formatDate(record.date)}</td>
          <td>${record.bean || "—"}</td>
          <td>${record.country || "—"}</td>
          <td>${record.roast || "—"}</td>
          <td>${record.rating || "—"}</td>
          <td>${record.shop || "—"}</td>
        `;
        const noteRow = document.createElement("tr");
        noteRow.classList.add("note-row");
        noteRow.style.display = "none";
        noteRow.innerHTML = `<td colspan="6">${record.note ? record.note : "ノートなし"}</td>`;
        row.addEventListener("click", () => {
          noteRow.style.display = noteRow.style.display === "none" ? "table-row" : "none";
        });
        tbody.appendChild(row);
        tbody.appendChild(noteRow);
      });

      document.getElementById("show-more").style.display = results.length > limit ? "inline-flex" : "none";
    }

    function setupSearch() {
      const input = document.getElementById("search-input");
      const debounced = debounce((value) => {
        state.search.query = value;
        state.search.limit = 100;
        renderSearchResults();
      }, 200);

      input.addEventListener("input", (event) => {
        debounced(event.target.value);
      });

      document.getElementById("show-more").addEventListener("click", () => {
        state.search.limit += 100;
        renderSearchResults();
      });
    }

    function setupRanking() {
      document.getElementById("ranking-modes").addEventListener("click", (event) => {
        if (event.target.tagName !== "BUTTON") return;
        state.rankingMode = event.target.dataset.mode;
        document.querySelectorAll("#ranking-modes button").forEach((btn) => btn.classList.remove("active"));
        event.target.classList.add("active");
        renderRanking();
      });

      ["input-bitter", "input-acid", "input-diff"].forEach((id) => {
        document.getElementById(id).addEventListener("input", () => renderRanking());
      });
    }

    function computeScore(record) {
      const bitter = validTaste(record.bitter);
      const acid = validTaste(record.acid);
      if (bitter === null || acid === null) return null;

      const inputBitter = Number(document.getElementById("input-bitter").value) || 3;
      const inputAcid = Number(document.getElementById("input-acid").value) || 3;
      const inputDiff = Number(document.getElementById("input-diff").value) || 0;

      if (state.rankingMode === "bitter") {
        return Math.abs(bitter - inputBitter);
      }
      if (state.rankingMode === "both") {
        return Math.hypot(bitter - inputBitter, acid - inputAcid);
      }
      return Math.abs((bitter - acid) - inputDiff);
    }

    function renderRanking() {
      const tbody = document.getElementById("ranking-results");
      tbody.innerHTML = "";
      const rows = state.records
        .map((record) => {
          const score = computeScore(record);
          if (score === null) return null;
          return { record, score };
        })
        .filter(Boolean)
        .sort((a, b) => {
          if (a.score !== b.score) return a.score - b.score;
          const dateDiff = getDateValue(b.record.date) - getDateValue(a.record.date);
          if (dateDiff !== 0) return dateDiff;
          return String(a.record.bean).localeCompare(String(b.record.bean));
        });

      rows.forEach(({ record, score }) => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${score.toFixed(2)}</td>
          <td>${record.bean || "—"}</td>
          <td>${record.country || "—"}</td>
          <td>${record.bitter || "—"}</td>
          <td>${record.acid || "—"}</td>
          <td>${record.rating || "—"}</td>
          <td>${formatDate(record.date)}</td>
        `;
        tbody.appendChild(row);
      });
    }

    function setupAnalysis() {
      document.querySelectorAll("input[name='rating-filter']").forEach((input) => {
        input.addEventListener("change", () => renderAnalysis());
      });

      const dialog = document.getElementById("ai-dialog");
      document.getElementById("ai-button").addEventListener("click", () => dialog.showModal());
      document.getElementById("ai-close").addEventListener("click", () => dialog.close());
    }

    function renderAnalysis() {
      const filterValue = document.querySelector("input[name='rating-filter']:checked").value;
      const filtered = state.records.filter((record) => {
        const rating = normalizeText(record.rating).toUpperCase();
        if (filterValue === "S") return rating === "s";
        return rating === "s" || rating === "a";
      });

      const sampleNote = document.getElementById("analysis-sample");
      if (filtered.length < 5) {
        sampleNote.textContent = `対象 ${filtered.length}件: サンプルが少ないため参考程度です。`;
      } else {
        sampleNote.textContent = `対象 ${filtered.length}件の傾向`;
      }

      const fields = ["country", "process", "roast", "bitter", "acid", "altitude", "shop"];
      const container = document.getElementById("analysis-traits");
      container.innerHTML = "";
      fields.forEach((field) => {
        const counts = new Map();
        filtered.forEach((record) => {
          const value = record[field] ? String(record[field]).trim() : "(不明)";
          counts.set(value, (counts.get(value) || 0) + 1);
        });
        const total = filtered.length || 1;
        const sorted = Array.from(counts.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 4);
        const list = sorted
          .map(([value, count]) => `${value}: ${(count / total * 100).toFixed(0)}% (${count})`)
          .join(" / ");
        const div = document.createElement("p");
        div.innerHTML = `<strong>${field}</strong>: ${list}`;
        container.appendChild(div);
      });

      renderScatter();
    }

    function ratingColor(rating) {
      const value = normalizeText(rating).toUpperCase();
      if (value === "S") return "#d35400";
      if (value === "A") return "#e67e22";
      if (value === "B") return "#f0b27a";
      if (value === "C") return "#f5cba7";
      return "#bfc9ca";
    }

    function renderScatter() {
      const canvas = document.getElementById("scatter");
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, width, height);

      const padding = 40;
      ctx.strokeStyle = "#d0c4b7";
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();

      ctx.fillStyle = "#6c6156";
      ctx.font = "12px sans-serif";
      ctx.fillText("Bitter", 8, 20);
      ctx.fillText("Acid", width - 60, height - 12);

      const points = state.records
        .map((record) => ({
          bitter: validTaste(record.bitter),
          acid: validTaste(record.acid),
          rating: record.rating
        }))
        .filter((point) => point.bitter !== null && point.acid !== null);

      points.forEach((point) => {
        const x = padding + (point.acid - 1) / 4 * (width - padding * 2);
        const y = height - padding - (point.bitter - 1) / 4 * (height - padding * 2);
        ctx.fillStyle = ratingColor(point.rating);
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    async function loadWorldData() {
      if (state.worldFeatures) return state.worldFeatures;
      const response = await fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
      const topo = await response.json();
      const features = topojson.feature(topo, topo.objects.countries).features;
      state.worldFeatures = features;
      return features;
    }

    function computeCountryCounts() {
      const map = new Map();
      state.records.forEach((record) => {
        const country = String(record.country || "").trim();
        const bean = String(record.bean || "").trim();
        if (!country || !bean) return;
        if (!map.has(country)) {
          map.set(country, new Set());
        }
        map.get(country).add(bean);
      });
      const counts = new Map();
      map.forEach((set, country) => {
        counts.set(country, set.size);
      });
      return counts;
    }

    async function renderMap() {
      const container = document.getElementById("map");
      container.innerHTML = "";
      const features = await loadWorldData();
      const nameToFeature = new Map(features.map((feature) => [feature.properties.name, feature]));
      const mapping = state.mapping;
      const rawCounts = computeCountryCounts();
      const mappedCounts = new Map();
      const unmapped = [];

      rawCounts.forEach((count, jpName) => {
        const mapKey = resolveMapKey(jpName, mapping);
        if (!mapKey || !nameToFeature.has(mapKey)) {
          unmapped.push({ name: jpName, count });
          return;
        }
        mappedCounts.set(mapKey, count);
      });

      const values = Array.from(mappedCounts.values()).sort((a, b) => a - b);
      const p95Index = values.length ? Math.floor((values.length - 1) * 0.95) : 0;
      const p95 = values.length ? values[p95Index] : 1;
      const scale = d3.scaleSequential(d3.interpolateYlOrBr).domain([0, Math.sqrt(p95)]);

      const width = 960;
      const height = 480;
      const svg = d3
        .select(container)
        .append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("role", "img")
        .attr("aria-label", "coffee origin map");
      const projection = d3.geoMercator().fitSize([width, height], { type: "FeatureCollection", features });
      const path = d3.geoPath(projection);

      svg
        .selectAll("path")
        .data(features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("fill", (feature) => {
          const value = mappedCounts.get(feature.properties.name) || 0;
          const capped = Math.min(value, p95);
          return value > 0 ? scale(Math.sqrt(capped)) : "#f5f3ef";
        })
        .attr("stroke", "#ffffff")
        .attr("stroke-width", 0.5);

      renderUnmapped(unmapped);
    }

    function renderUnmapped(unmapped) {
      const list = document.getElementById("unmapped-list");
      const select = document.getElementById("unmapped-select");
      list.innerHTML = "";
      select.innerHTML = "";

      if (!unmapped.length) {
        list.textContent = "すべてマッピング済みです。";
        return;
      }

      const chips = document.createElement("div");
      chips.style.display = "flex";
      chips.style.flexWrap = "wrap";
      chips.style.gap = "6px";
      unmapped.forEach((entry) => {
        const chip = document.createElement("span");
        chip.className = "pill";
        chip.textContent = `${entry.name} (${entry.count})`;
        chips.appendChild(chip);
        const option = document.createElement("option");
        option.value = entry.name;
        option.textContent = entry.name;
        select.appendChild(option);
      });
      list.appendChild(chips);
    }

    function setupMap() {
      state.mapping = loadMapping();
      document.getElementById("save-mapping").addEventListener("click", () => {
        const select = document.getElementById("unmapped-select");
        const input = document.getElementById("mapping-input");
        const country = select.value;
        const value = input.value.trim();
        if (!country || !value) return;
        state.mapping[country] = value;
        saveMapping(state.mapping);
        input.value = "";
        renderMap();
      });
    }

    function renderAll() {
      renderSearchResults();
      renderRanking();
      renderAnalysis();
      renderMap();
    }

    reloadBtn.addEventListener("click", () => {
      localStorage.removeItem(LS_KEY);
      loadData(true);
    });

    setupTabs();
    setupSearchColumns();
    setupSearch();
    setupRanking();
    setupAnalysis();
    setupMap();
    loadData();
  </script>
</body>
</html>
