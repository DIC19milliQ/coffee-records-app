<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coffee Records</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Noto Sans JP", system-ui, -apple-system, sans-serif;
      --bg: #f7f5f2;
      --card: #ffffff;
      --text: #2f2a24;
      --muted: #6c6156;
      --accent: #7b4e2e;
      --accent-soft: #f1e4d8;
      --line: #e2d8cd;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 20px 16px 12px;
      background: var(--card);
      border-bottom: 1px solid var(--line);
    }
    header h1 {
      margin: 0 0 8px;
      font-size: 1.6rem;
    }
    .header-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    button {
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      padding: 6px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button.ghost {
      background: transparent;
      color: var(--accent);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    nav {
      display: flex;
      gap: 6px;
      padding: 8px 16px;
      background: var(--card);
      border-bottom: 1px solid var(--line);
      position: sticky;
      top: 0;
      z-index: 10;
      overflow-x: auto;
    }
    nav button {
      background: var(--accent-soft);
      color: var(--text);
      border: 1px solid var(--line);
      padding: 6px 14px;
      border-radius: 999px;
      white-space: nowrap;
    }
    nav button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    main {
      padding: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .tab-panel {
      display: none;
      gap: 16px;
      flex-direction: column;
    }
    .tab-panel.active {
      display: flex;
    }
    .card {
      background: var(--card);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.04);
      border: 1px solid var(--line);
    }
    .card h2 {
      margin-top: 0;
    }
    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .filters > input[type="text"] {
      flex: 1;
      min-width: 220px;
    }
    .checkbox-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 12px;
    }
    input[type="text"], input[type="number"], select {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--line);
      width: 100%;
      font-size: 0.95rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--line);
      vertical-align: top;
    }
    th.sortable {
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    tr.expandable {
      cursor: pointer;
    }
    tr.expandable:hover {
      background: #faf6f2;
    }
    .tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: var(--accent-soft);
      color: var(--text);
    }
    .mode-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .mode-buttons button {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--line);
    }
    .mode-buttons button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }
    .muted {
      color: var(--muted);
    }
    .result-count {
      font-size: 0.9rem;
      color: var(--muted);
    }
    .chart-container {
      width: 100%;
      overflow-x: auto;
    }
    canvas {
      width: 100%;
      max-width: 640px;
      height: 360px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
    }
    #map {
      width: 100%;
      overflow-x: auto;
    }
    #map svg {
      width: 100%;
      height: auto;
      min-height: 360px;
    }
    .legend {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .legend-bar {
      width: 160px;
      height: 10px;
      background: linear-gradient(90deg, #f5f3ef, #e0b98c, #c8783b, #8b3f1f);
      border-radius: 999px;
      border: 1px solid var(--line);
    }
    .pill {
      background: var(--accent-soft);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.8rem;
    }
    .quick-filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .filter-group {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
    }
    .filter-group h3 {
      margin: 0 0 8px;
      font-size: 0.9rem;
    }
    .option-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .option-list label {
      font-size: 0.85rem;
    }
    .sheet {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--card);
      border-radius: 16px 16px 0 0;
      border: 1px solid var(--line);
      border-bottom: none;
      box-shadow: 0 -8px 20px rgba(0,0,0,0.12);
      transform: translateY(105%);
      transition: transform 0.2s ease;
      z-index: 40;
      max-height: 82vh;
      display: flex;
      flex-direction: column;
    }
    .sheet.open { transform: translateY(0); }
    .sheet-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      z-index: 30;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }
    .sheet-backdrop.open {
      opacity: 1;
      pointer-events: auto;
    }
    .sheet-header {
      position: sticky;
      top: 0;
      background: var(--card);
      padding: 10px 16px;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1;
    }
    .sheet-content {
      padding: 12px 16px 20px;
      overflow-y: auto;
    }
    .sheet-note {
      white-space: pre-wrap;
      line-height: 1.5;
      word-break: break-word;
    }
    .sub-toggle {
      margin: 12px 0;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px;
      background: #fff;
    }
    .similar-list {
      margin: 6px 0 0;
      padding-left: 18px;
    }
    dialog {
      border: none;
      border-radius: 16px;
      padding: 0;
      max-width: 520px;
      width: 90%;
    }
    dialog::backdrop {
      background: rgba(0,0,0,0.3);
    }
    .dialog-body {
      padding: 20px;
    }
    .dialog-actions {
      display: flex;
      justify-content: flex-end;
      padding: 12px 20px 20px;
      gap: 8px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
</head>
<body>
  <header>
    <h1>コーヒー豆記録</h1>
    <div class="header-row">
      <div id="status" class="muted">読み込み中...</div>
      <div class="header-actions">
        <span class="pill">最終取得: <span id="updated-at">--</span></span>
        <button id="reload">再取得</button>
      </div>
    </div>
  </header>
  <nav>
    <button class="active" data-tab="search">Search</button>
    <button data-tab="ranking">Ranking</button>
    <button data-tab="analysis">Analysis</button>
    <button data-tab="map">Map</button>
  </nav>
  <main>
    <section id="tab-search" class="tab-panel active">
      <div class="card">
        <h2>検索 / 図鑑</h2>
        <div class="filters">
          <input id="search-input" type="text" placeholder="キーワードを入力（スペースでAND検索）" />
          <span class="result-count" id="search-count">0件</span>
        </div>
        <div class="quick-filters" id="quick-filters"></div>
        <h3 style="margin:14px 0 6px;font-size:0.95rem;">表示列</h3>
        <div class="checkbox-grid" id="search-columns"></div>
      </div>
      <div class="card">
        <div class="table-wrap">
          <table>
            <thead>
              <tr id="search-head"></tr>
            </thead>
            <tbody id="search-results"></tbody>
          </table>
        </div>
        <div style="margin-top:12px;">
          <button id="show-more" class="ghost">もっと見る</button>
        </div>
      </div>
    </section>

    <section id="tab-ranking" class="tab-panel">
      <div class="card">
        <h2>ランキング：気分入力</h2>
        <div class="mode-buttons" id="ranking-modes">
          <button data-mode="bitter" class="active">苦味のみ</button>
          <button data-mode="both">苦味 + 酸味</button>
          <button data-mode="diff">差分 (苦味 - 酸味)</button>
        </div>
        <div class="grid-2" style="margin-top:12px;">
          <div>
            <label>苦味 (1-5)</label>
            <input id="input-bitter" type="number" min="1" max="5" step="1" value="3" />
          </div>
          <div>
            <label>酸味 (1-5)</label>
            <input id="input-acid" type="number" min="1" max="5" step="1" value="3" />
          </div>
          <div>
            <label>差分 (苦味 - 酸味)</label>
            <input id="input-diff" type="number" min="-4" max="4" step="1" value="0" />
          </div>
        </div>
        <p class="muted" id="ranking-note">有効な苦味/酸味のみ対象。近い順に表示されます。</p>
      </div>
      <div class="card">
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>スコア</th>
                <th>豆</th>
                <th>産地</th>
                <th>苦味</th>
                <th>酸味</th>
                <th>評価</th>
                <th>日付</th>
              </tr>
            </thead>
            <tbody id="ranking-results"></tbody>
          </table>
        </div>
      </div>
    </section>

    <section id="tab-analysis" class="tab-panel">
      <div class="grid-2">
        <div class="card">
          <h2>高評価豆の共通点</h2>
          <div class="filters">
            <label><input type="radio" name="rating-filter" value="S" checked /> Sのみ</label>
            <label><input type="radio" name="rating-filter" value="SA" /> S + A</label>
          </div>
          <p id="analysis-sample" class="muted"></p>
          <div id="analysis-traits"></div>
        </div>
        <div class="card">
          <h2>苦味 x 酸味 マップ</h2>
          <div class="chart-container">
            <canvas id="scatter" width="640" height="360"></canvas>
          </div>
          <div class="legend">
            <span class="tag">S</span>
            <span class="tag">A</span>
            <span class="tag">B</span>
            <span class="tag">C</span>
            <span class="tag">その他</span>
          </div>
        </div>
      </div>
      <div class="card">
        <h2>AI分析（準備中）</h2>
        <p class="muted">現在は集計結果の確認のみ。将来は集計結果をAIに渡す想定です。</p>
        <button id="ai-button">AI分析へ切替</button>
      </div>
    </section>

    <section id="tab-map" class="tab-panel">
      <div class="card">
        <h2>コンプリート地図</h2>
        <p class="muted">国ごとの豆の種類数（ユニーク数）を可視化。P95で上限を切り、平方根スケールで色付けしています。</p>
        <div id="map"></div>
        <div class="legend">
          <span>少ない</span>
          <div class="legend-bar"></div>
          <span>多い</span>
        </div>
      </div>
      <div class="card">
        <h3>未マッピングの国</h3>
        <p class="muted">地図側の国名またはISO2コードを登録してください。</p>
        <div id="unmapped-list"></div>
        <div class="grid-2" style="margin-top:12px;">
          <div>
            <label>対象国</label>
            <select id="unmapped-select"></select>
          </div>
          <div>
            <label>マップキー（国名 or ISO2）</label>
            <input id="mapping-input" type="text" placeholder="例: Brazil / BR" />
          </div>
        </div>
        <button id="save-mapping" style="margin-top:12px;">マッピング保存</button>
      </div>
    </section>
  </main>

  <div id="sheet-backdrop" class="sheet-backdrop"></div>
  <section id="record-sheet" class="sheet" aria-label="記録詳細">
    <div class="sheet-header">
      <strong id="sheet-title">記録詳細</strong>
      <button id="sheet-close" class="ghost">閉じる</button>
    </div>
    <div class="sheet-content">
      <h3 style="margin-top:0;">ノート</h3>
      <p id="sheet-note" class="sheet-note">ノートなし</p>
      <details id="sheet-sub" class="sub-toggle">
        <summary>サブ情報を表示 ▾</summary>
        <div id="sheet-sub-content" style="margin-top:8px;"></div>
      </details>
      <h3 style="margin-bottom:6px;">近い味の記録</h3>
      <ol id="sheet-similar" class="similar-list"></ol>
    </div>
  </section>

  <dialog id="ai-dialog">
    <div class="dialog-body">
      <h3>AI分析は準備中です</h3>
      <p class="muted">今後は集計データのみをAIに渡して分析する想定です。現時点ではAPI連携は行いません。</p>
    </div>
    <div class="dialog-actions">
      <button id="ai-close" class="ghost">閉じる</button>
    </div>
  </dialog>

  <script>
    const API_URL = "https://script.google.com/macros/s/AKfycbwTVElQ-Ao7U2lb3MGsYFj_Qy5K0C1bSw_IPk0ZFNPV9d0mGrpOZuukZCW9rbOgtc_6/exec";
    const TTL_MS = 60 * 60 * 1000;
    const LS_KEY = "coffeeRecordsCache_v2";
    const MAP_KEY = "coffeeCountryMapping_v1";
    const SEARCH_PREFS_KEY = "coffeeSearchPrefs_v1";

    const SEARCH_COLUMNS = [
      { key: "country", label: "国" },
      { key: "bean", label: "豆" },
      { key: "altitude", label: "標高" },
      { key: "process", label: "精製" },
      { key: "roast", label: "焙煎" },
      { key: "rating", label: "評価" },
      { key: "shop", label: "ショップ" },
      { key: "price", label: "価格" },
      { key: "bitter", label: "苦味" },
      { key: "acid", label: "酸味" },
      { key: "date", label: "日付" },
      { key: "region", label: "地域" },
      { key: "note", label: "ノート" }
    ];
    const DEFAULT_VISIBLE_COLUMNS = ["country", "bean", "altitude", "process", "roast", "rating"];

    const DEFAULT_MAPPING = {
      "ブラジル": "Brazil", "コロンビア": "Colombia", "エチオピア": "Ethiopia", "グアテマラ": "Guatemala", "ホンジュラス": "Honduras", "インドネシア": "Indonesia", "ケニア": "Kenya", "ペルー": "Peru", "ルワンダ": "Rwanda", "タンザニア": "Tanzania", "ベトナム": "Vietnam", "イエメン": "Yemen", "コスタリカ": "Costa Rica", "パナマ": "Panama", "ボリビア": "Bolivia", "ブルンジ": "Burundi", "エクアドル": "Ecuador", "エルサルバドル": "El Salvador", "インド": "India", "ジャマイカ": "Jamaica", "ニカラグア": "Nicaragua", "パプアニューギニア": "Papua New Guinea", "ウガンダ": "Uganda"
    };
    const ISO2_TO_NAME = { BR: "Brazil", CO: "Colombia", ET: "Ethiopia", GT: "Guatemala", HN: "Honduras", ID: "Indonesia", KE: "Kenya", PE: "Peru", RW: "Rwanda", TZ: "Tanzania", VN: "Vietnam", YE: "Yemen", CR: "Costa Rica", PA: "Panama", BO: "Bolivia", BI: "Burundi", EC: "Ecuador", SV: "El Salvador", IN: "India", JM: "Jamaica", NI: "Nicaragua", PG: "Papua New Guinea", UG: "Uganda", US: "United States of America", JP: "Japan" };

    const state = {
      records: [], updatedAt: "--",
      search: { query: "", columns: new Set(DEFAULT_VISIBLE_COLUMNS), limit: 100, sortKey: "date", sortDir: "desc", filters: { rating: new Set(), roast: new Set(), shop: new Set(), bitterMin: "", bitterMax: "", acidMin: "", acidMax: "" } },
      selectedRecord: null,
      rankingMode: "bitter", worldFeatures: null, mapping: {}
    };

    const statusEl = document.getElementById("status");
    const updatedEl = document.getElementById("updated-at");
    const reloadBtn = document.getElementById("reload");

    const normalizeText = (v) => String(v ?? "").replace(/^﻿/, "").normalize("NFKC").toLowerCase().trim();
    const validTaste = (v) => { const n = Number(v); return Number.isFinite(n) && n >= 1 && n <= 5 ? n : null; };
    function formatDate(v) { if (!v) return "未記録"; const t = Date.parse(v); if (!Number.isFinite(t)) return "未記録"; const d = new Date(t); return `${d.getFullYear()}/${String(d.getMonth() + 1).padStart(2, "0")}/${String(d.getDate()).padStart(2, "0")}`; }
    function getDateValue(v) { const t = Date.parse(v); return Number.isFinite(t) ? t : null; }
    function display(v) { return String(v || "").trim() || "未記録"; }

    function isHeaderRow(record) {
      const fields = ["region", "country", "bean", "altitude", "process", "roast", "price", "rating", "bitter", "acid", "note", "shop", "date"];
      return fields.some((field) => normalizeText(record[field]) === field);
    }

    function safeParseJson(text) { return JSON.parse(text.replace(/^﻿/, "")); }
    function cacheSet(payload) { localStorage.setItem(LS_KEY, JSON.stringify({ savedAt: Date.now(), payload })); }
    function cacheGet() { try { const p = JSON.parse(localStorage.getItem(LS_KEY) || "null"); if (!p?.savedAt || !p?.payload) return null; if (Date.now() - p.savedAt > TTL_MS) return null; return p.payload; } catch { return null; } }
    function loadMapping() { try { return { ...DEFAULT_MAPPING, ...(JSON.parse(localStorage.getItem(MAP_KEY) || "{}")) }; } catch { return { ...DEFAULT_MAPPING }; } }
    function saveMapping(mapping) { localStorage.setItem(MAP_KEY, JSON.stringify(mapping)); }

    function saveSearchPrefs() {
      const f = state.search.filters;
      const payload = { columns: [...state.search.columns], sortKey: state.search.sortKey, sortDir: state.search.sortDir, filters: { rating: [...f.rating], roast: [...f.roast], shop: [...f.shop], bitterMin: f.bitterMin, bitterMax: f.bitterMax, acidMin: f.acidMin, acidMax: f.acidMax } };
      localStorage.setItem(SEARCH_PREFS_KEY, JSON.stringify(payload));
    }
    function loadSearchPrefs() {
      try {
        const p = JSON.parse(localStorage.getItem(SEARCH_PREFS_KEY) || "null");
        if (!p) return;
        const keys = new Set(SEARCH_COLUMNS.map((c) => c.key));
        const cols = (p.columns || []).filter((k) => keys.has(k));
        state.search.columns = new Set(cols.length ? cols : DEFAULT_VISIBLE_COLUMNS);
        if (["asc", "desc"].includes(p.sortDir)) state.search.sortDir = p.sortDir;
        if (keys.has(p.sortKey) || p.sortKey === "date") state.search.sortKey = p.sortKey || "date";
        const f = p.filters || {};
        state.search.filters.rating = new Set(f.rating || []);
        state.search.filters.roast = new Set(f.roast || []);
        state.search.filters.shop = new Set(f.shop || []);
        state.search.filters.bitterMin = f.bitterMin ?? "";
        state.search.filters.bitterMax = f.bitterMax ?? "";
        state.search.filters.acidMin = f.acidMin ?? "";
        state.search.filters.acidMax = f.acidMax ?? "";
      } catch {}
    }

    async function fetchRecords() { statusEl.textContent = "取得中..."; const response = await fetch(API_URL, { method: "GET" }); if (!response.ok) throw new Error(`API error: ${response.status}`); return safeParseJson(await response.text()); }
    function sanitizeRecords(items) { return Array.isArray(items) ? items.filter((i) => i && typeof i === "object").filter((i) => !isHeaderRow(i)).map((i) => { const c = {}; const fields = ["region","country","bean","altitude","process","roast","price","rating","bitter","acid","note","shop","date"]; fields.forEach((k) => c[k] = i[k] ?? ""); c._norm = {}; fields.forEach((k) => c._norm[k] = normalizeText(c[k])); return c; }) : []; }
    function updateStatus(text) { statusEl.textContent = text; }
    function updateUpdatedAt(value) { updatedEl.textContent = value || "--"; }

    async function loadData(force = false) {
      reloadBtn.disabled = true;
      try {
        if (!force) {
          const cached = cacheGet();
          if (cached) { state.records = sanitizeRecords(cached.items || []); state.updatedAt = cached.updatedAt || cached.fetchedAt || "--"; updateStatus("キャッシュから読み込み"); updateUpdatedAt(state.updatedAt); renderAll(); reloadBtn.disabled = false; return; }
        }
        const data = await fetchRecords();
        const fetchedAt = new Date().toISOString();
        cacheSet({ items: data.items || [], updatedAt: data.updatedAt, fetchedAt });
        state.records = sanitizeRecords(data.items || []);
        state.updatedAt = data.updatedAt || fetchedAt;
        updateStatus("APIから読み込み"); updateUpdatedAt(state.updatedAt); renderAll();
      } catch (error) { updateStatus(`エラー: ${error.message}`); }
      finally { reloadBtn.disabled = false; }
    }

    function setupTabs() { document.querySelectorAll("nav button").forEach((button) => button.addEventListener("click", () => { document.querySelectorAll("nav button").forEach((btn) => btn.classList.remove("active")); document.querySelectorAll(".tab-panel").forEach((panel) => panel.classList.remove("active")); button.classList.add("active"); document.getElementById(`tab-${button.dataset.tab}`).classList.add("active"); })); }
    function debounce(fn, delay) { let timer = null; return (...args) => { if (timer) clearTimeout(timer); timer = setTimeout(() => fn(...args), delay); }; }

    function getQuickOptions(key) { return [...new Set(state.records.map((r) => String(r[key] || "").trim()).filter(Boolean))].sort((a,b)=>a.localeCompare(b,"ja")); }

    function renderQuickFilters() {
      const wrap = document.getElementById("quick-filters");
      const f = state.search.filters;
      const makeChecks = (key, title, options) => `<div class="filter-group"><h3>${title}</h3><div class="option-list">${options.map((op)=>`<label><input type="checkbox" data-filter="${key}" value="${op}" ${f[key].has(op)?"checked":""}/> ${op}</label>`).join("") || "<span class=\"muted\">候補なし</span>"}</div></div>`;
      wrap.innerHTML = [
        makeChecks("rating", "評価", ["S","A","B","C"]),
        makeChecks("roast", "焙煎", ["浅","中","中深","深"]),
        makeChecks("shop", "ショップ", getQuickOptions("shop")),
        `<div class="filter-group"><h3>苦味 / 酸味</h3><div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;"><label>苦味最小<input id="f-bitter-min" type="number" min="1" max="5" value="${f.bitterMin}"></label><label>苦味最大<input id="f-bitter-max" type="number" min="1" max="5" value="${f.bitterMax}"></label><label>酸味最小<input id="f-acid-min" type="number" min="1" max="5" value="${f.acidMin}"></label><label>酸味最大<input id="f-acid-max" type="number" min="1" max="5" value="${f.acidMax}"></label></div></div>`
      ].join("");

      wrap.querySelectorAll("input[data-filter]").forEach((input) => input.addEventListener("change", () => {
        const key = input.dataset.filter; if (input.checked) f[key].add(input.value); else f[key].delete(input.value);
        state.search.limit = 100; saveSearchPrefs(); renderSearchResults();
      }));
      [["f-bitter-min","bitterMin"],["f-bitter-max","bitterMax"],["f-acid-min","acidMin"],["f-acid-max","acidMax"]].forEach(([id,key])=>{
        const el = document.getElementById(id); el.addEventListener("input",()=>{ f[key] = el.value; state.search.limit = 100; saveSearchPrefs(); renderSearchResults(); });
      });
    }

    function setupSearchColumns() {
      const container = document.getElementById("search-columns");
      container.innerHTML = "";
      SEARCH_COLUMNS.forEach((col) => {
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = state.search.columns.has(col.key);
        checkbox.addEventListener("change", () => { if (checkbox.checked) state.search.columns.add(col.key); else state.search.columns.delete(col.key); saveSearchPrefs(); renderSearchResults(); });
        label.appendChild(checkbox); label.append(` ${col.label}`); container.appendChild(label);
      });
    }

    function buildSearchHead() {
      const head = document.getElementById("search-head");
      const visible = SEARCH_COLUMNS.filter((c) => state.search.columns.has(c.key));
      if (!visible.length) visible.push(...SEARCH_COLUMNS.filter((c)=>DEFAULT_VISIBLE_COLUMNS.includes(c.key)));
      head.innerHTML = visible.map((c) => `<th class="sortable" data-key="${c.key}">${c.label}${state.search.sortKey===c.key ? (state.search.sortDir==='asc'?' ▲':' ▼') : ''}</th>`).join("");
      head.querySelectorAll("th").forEach((th)=>th.addEventListener("click",()=>{ const key = th.dataset.key; if (state.search.sortKey===key) state.search.sortDir = state.search.sortDir==='asc'?'desc':'asc'; else { state.search.sortKey = key; state.search.sortDir = 'asc'; } saveSearchPrefs(); renderSearchResults(); }));
      return visible;
    }

    function applyFilters(records) {
      const tokens = normalizeText(state.search.query).split(/\s+/).filter(Boolean);
      const f = state.search.filters;
      return records.filter((record) => {
        const allText = SEARCH_COLUMNS.map((c) => record._norm[c.key]).join(" ");
        if (!tokens.every((token) => allText.includes(token))) return false;
        if (f.rating.size && !f.rating.has(String(record.rating || "").trim())) return false;
        if (f.roast.size && !f.roast.has(String(record.roast || "").trim())) return false;
        if (f.shop.size && !f.shop.has(String(record.shop || "").trim())) return false;
        const b = validTaste(record.bitter); const a = validTaste(record.acid);
        const within = (v,min,max) => (min==="" || (v!==null && v>=Number(min))) && (max==="" || (v!==null && v<=Number(max)));
        if (!within(b, f.bitterMin, f.bitterMax)) return false;
        if (!within(a, f.acidMin, f.acidMax)) return false;
        return true;
      });
    }

    function compareRecords(a, b) {
      const key = state.search.sortKey; const dir = state.search.sortDir === "asc" ? 1 : -1;
      if (key === "date") {
        const ta = getDateValue(a.date); const tb = getDateValue(b.date);
        if (ta === null && tb === null) return 0; if (ta === null) return 1; if (tb === null) return -1;
        return (ta - tb) * dir;
      }
      const na = Number(a[key]); const nb = Number(b[key]);
      if (Number.isFinite(na) && Number.isFinite(nb)) { if (na !== nb) return (na - nb) * dir; }
      const s = String(a[key] || "").localeCompare(String(b[key] || ""), "ja");
      if (s !== 0) return s * dir;
      return (getDateValue(b.date) || -Infinity) - (getDateValue(a.date) || -Infinity);
    }

    function similarTaste(record) {
      const b = validTaste(record.bitter); const a = validTaste(record.acid);
      if (b === null || a === null) return [];
      return state.records.map((r)=>({ r, db: validTaste(r.bitter), da: validTaste(r.acid) }))
        .filter((x)=>x.r!==record && x.db!==null && x.da!==null)
        .map((x)=>({ record: x.r, dist: (x.db-b)**2 + (x.da-a)**2 }))
        .sort((x,y)=>x.dist-y.dist)
        .slice(0,5);
    }

    function openRecordSheet(record) {
      state.selectedRecord = record;
      document.getElementById("sheet-title").textContent = `${display(record.bean)} / ${display(record.country)}`;
      document.getElementById("sheet-note").textContent = record.note || "ノートなし";
      document.getElementById("sheet-sub-content").innerHTML = `
        <div class="muted">苦味: ${display(record.bitter)} / 酸味: ${display(record.acid)}</div>
        <div class="muted">ショップ: ${display(record.shop)}</div>
        <div class="muted">価格: ${display(record.price)}</div>
        <div class="muted">日付: ${formatDate(record.date)}</div>`;
      const similar = similarTaste(record);
      document.getElementById("sheet-similar").innerHTML = similar.length ? similar.map(({record:r, dist}) => `<li>${display(r.bean)} (${display(r.country)}) / 苦味:${display(r.bitter)} 酸味:${display(r.acid)} / ${formatDate(r.date)} <span class="muted">(距離:${dist.toFixed(2)})</span></li>`).join("") : "<li>比較可能な記録がありません</li>";
      document.getElementById("sheet-backdrop").classList.add("open");
      document.getElementById("record-sheet").classList.add("open");
      document.getElementById("sheet-sub").open = false;
    }
    function closeRecordSheet() { document.getElementById("sheet-backdrop").classList.remove("open"); document.getElementById("record-sheet").classList.remove("open"); }

    function renderSearchResults() {
      const tbody = document.getElementById("search-results");
      tbody.innerHTML = "";
      const visible = buildSearchHead();
      const results = applyFilters(state.records).sort(compareRecords);
      const limit = state.search.limit;
      document.getElementById("search-count").textContent = `${results.length}件`;
      results.slice(0, limit).forEach((record) => {
        const row = document.createElement("tr"); row.classList.add("expandable");
        row.innerHTML = visible.map((col) => `<td>${col.key === 'date' ? formatDate(record.date) : display(record[col.key])}</td>`).join("");
        row.addEventListener("click", () => openRecordSheet(record));
        tbody.appendChild(row);
      });
      document.getElementById("show-more").style.display = results.length > limit ? "inline-flex" : "none";
    }

    function setupSearch() {
      const input = document.getElementById("search-input");
      input.value = state.search.query;
      const debounced = debounce((value) => { state.search.query = value; state.search.limit = 100; renderSearchResults(); }, 200);
      input.addEventListener("input", (event) => debounced(event.target.value));
      document.getElementById("show-more").addEventListener("click", () => { state.search.limit += 100; renderSearchResults(); });
      document.getElementById("sheet-close").addEventListener("click", closeRecordSheet);
      document.getElementById("sheet-backdrop").addEventListener("click", closeRecordSheet);
    }

    function setupRanking() { document.getElementById("ranking-modes").addEventListener("click", (event) => { if (event.target.tagName !== "BUTTON") return; state.rankingMode = event.target.dataset.mode; document.querySelectorAll("#ranking-modes button").forEach((btn) => btn.classList.remove("active")); event.target.classList.add("active"); renderRanking(); }); ["input-bitter", "input-acid", "input-diff"].forEach((id) => document.getElementById(id).addEventListener("input", () => renderRanking())); }
    function computeScore(record) { const bitter = validTaste(record.bitter); const acid = validTaste(record.acid); if (bitter === null || acid === null) return null; const inputBitter = Number(document.getElementById("input-bitter").value) || 3; const inputAcid = Number(document.getElementById("input-acid").value) || 3; const inputDiff = Number(document.getElementById("input-diff").value) || 0; if (state.rankingMode === "bitter") return Math.abs(bitter - inputBitter); if (state.rankingMode === "both") return Math.hypot(bitter - inputBitter, acid - inputAcid); return Math.abs((bitter - acid) - inputDiff); }
    function renderRanking() { const tbody = document.getElementById("ranking-results"); tbody.innerHTML = ""; state.records.map((record) => ({ record, score: computeScore(record) })).filter((x) => x.score !== null).sort((a,b) => a.score - b.score || ((getDateValue(b.record.date)||-Infinity) - (getDateValue(a.record.date)||-Infinity))).forEach(({record,score})=>{ const row = document.createElement("tr"); row.innerHTML = `<td>${score.toFixed(2)}</td><td>${display(record.bean)}</td><td>${display(record.country)}</td><td>${display(record.bitter)}</td><td>${display(record.acid)}</td><td>${display(record.rating)}</td><td>${formatDate(record.date)}</td>`; tbody.appendChild(row); }); }

    function setupAnalysis() { document.querySelectorAll("input[name='rating-filter']").forEach((input) => input.addEventListener("change", () => renderAnalysis())); const dialog = document.getElementById("ai-dialog"); document.getElementById("ai-button").addEventListener("click", () => dialog.showModal()); document.getElementById("ai-close").addEventListener("click", () => dialog.close()); }
    function renderAnalysis() { const filterValue = document.querySelector("input[name='rating-filter']:checked").value; const filtered = state.records.filter((record) => { const rating = normalizeText(record.rating).toUpperCase(); if (filterValue === "S") return rating === "S"; return rating === "S" || rating === "A"; }); document.getElementById("analysis-sample").textContent = filtered.length < 5 ? `対象 ${filtered.length}件: サンプルが少ないため参考程度です。` : `対象 ${filtered.length}件の傾向`; const fields = ["country", "process", "roast", "bitter", "acid", "altitude", "shop"]; const container = document.getElementById("analysis-traits"); container.innerHTML = ""; fields.forEach((field) => { const counts = new Map(); filtered.forEach((record) => { const value = record[field] ? String(record[field]).trim() : "(不明)"; counts.set(value, (counts.get(value) || 0) + 1); }); const total = filtered.length || 1; const labelMap = { bitter: "苦味", acid: "酸味", country: "国", process: "精製", roast: "焙煎", altitude: "標高", shop: "ショップ" }; const list = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,4).map(([v,c])=>`${v}: ${(c / total * 100).toFixed(0)}% (${c})`).join(" / "); const div = document.createElement("p"); div.innerHTML = `<strong>${labelMap[field] || field}</strong>: ${list}`; container.appendChild(div); }); renderScatter(); }
    function ratingColor(rating) { const value = normalizeText(rating).toUpperCase(); if (value === "S") return "#d35400"; if (value === "A") return "#e67e22"; if (value === "B") return "#f0b27a"; if (value === "C") return "#f5cba7"; return "#bfc9ca"; }
    function renderScatter() { const canvas = document.getElementById("scatter"); const ctx = canvas.getContext("2d"); const width = canvas.width; const height = canvas.height; ctx.clearRect(0,0,width,height); ctx.fillStyle="#fff"; ctx.fillRect(0,0,width,height); const p=40; ctx.strokeStyle="#d0c4b7"; ctx.beginPath(); ctx.moveTo(p,p); ctx.lineTo(p,height-p); ctx.lineTo(width-p,height-p); ctx.stroke(); ctx.fillStyle="#6c6156"; ctx.font="12px sans-serif"; ctx.fillText("苦味",8,20); ctx.fillText("酸味",width-40,height-12); state.records.map((r)=>({b:validTaste(r.bitter),a:validTaste(r.acid),rating:r.rating})).filter((pt)=>pt.b!==null&&pt.a!==null).forEach((pt)=>{ const x = p + (pt.a - 1)/4*(width-p*2); const y = height-p-(pt.b-1)/4*(height-p*2); ctx.fillStyle=ratingColor(pt.rating); ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); }); }

    async function loadWorldData() { if (state.worldFeatures) return state.worldFeatures; const response = await fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json"); const topo = await response.json(); const features = topojson.feature(topo, topo.objects.countries).features; state.worldFeatures = features; return features; }
    function resolveMapKey(jpName, mapping) { const mapped = mapping[jpName]; if (!mapped) return null; const trimmed = mapped.trim(); if (trimmed.length === 2) { const upper = trimmed.toUpperCase(); return ISO2_TO_NAME[upper] || null; } return trimmed; }
    function computeCountryCounts() { const map = new Map(); state.records.forEach((record)=>{ const country = String(record.country||"").trim(); const bean = String(record.bean||"").trim(); if(!country||!bean) return; if(!map.has(country)) map.set(country,new Set()); map.get(country).add(bean); }); const counts = new Map(); map.forEach((set,country)=>counts.set(country,set.size)); return counts; }
    async function renderMap() { const container = document.getElementById("map"); container.innerHTML = ""; const features = await loadWorldData(); const nameToFeature = new Map(features.map((feature)=>[feature.properties.name, feature])); const mapping = state.mapping; const rawCounts = computeCountryCounts(); const mappedCounts = new Map(); const unmapped = []; rawCounts.forEach((count,jpName)=>{ const mapKey = resolveMapKey(jpName,mapping); if(!mapKey||!nameToFeature.has(mapKey)) { unmapped.push({name:jpName,count}); return; } mappedCounts.set(mapKey,count); }); const values = [...mappedCounts.values()].sort((a,b)=>a-b); const p95 = values.length ? values[Math.floor((values.length - 1) * 0.95)] : 1; const scale = d3.scaleSequential(d3.interpolateYlOrBr).domain([0, Math.sqrt(p95)]); const width = 960; const height = 480; const svg = d3.select(container).append("svg").attr("viewBox", `0 0 ${width} ${height}`).attr("role", "img").attr("aria-label", "coffee origin map"); const projection = d3.geoMercator().fitSize([width, height], { type: "FeatureCollection", features }); const path = d3.geoPath(projection); svg.selectAll("path").data(features).enter().append("path").attr("d", path).attr("fill", (feature) => { const value = mappedCounts.get(feature.properties.name) || 0; const capped = Math.min(value,p95); return value > 0 ? scale(Math.sqrt(capped)) : "#f5f3ef"; }).attr("stroke", "#ffffff").attr("stroke-width", 0.5); renderUnmapped(unmapped); }
    function renderUnmapped(unmapped) { const list = document.getElementById("unmapped-list"); const select = document.getElementById("unmapped-select"); list.innerHTML = ""; select.innerHTML = ""; if (!unmapped.length) { list.textContent = "すべてマッピング済みです。"; return; } const chips = document.createElement("div"); chips.style.display = "flex"; chips.style.flexWrap = "wrap"; chips.style.gap = "6px"; unmapped.forEach((entry)=>{ const chip = document.createElement("span"); chip.className="pill"; chip.textContent=`${entry.name} (${entry.count})`; chips.appendChild(chip); const option=document.createElement("option"); option.value=entry.name; option.textContent=entry.name; select.appendChild(option); }); list.appendChild(chips); }
    function setupMap() { state.mapping = loadMapping(); document.getElementById("save-mapping").addEventListener("click", ()=>{ const select = document.getElementById("unmapped-select"); const input = document.getElementById("mapping-input"); const country = select.value; const value = input.value.trim(); if(!country||!value) return; state.mapping[country]=value; saveMapping(state.mapping); input.value=""; renderMap(); }); }

    function renderAll() { renderQuickFilters(); renderSearchResults(); setupSearchColumns(); renderRanking(); renderAnalysis(); renderMap(); }

    reloadBtn.addEventListener("click", () => { localStorage.removeItem(LS_KEY); loadData(true); });

    loadSearchPrefs();
    setupTabs();
    setupSearch();
    setupRanking();
    setupAnalysis();
    setupMap();
    loadData();
  </script>

</body>
</html>
